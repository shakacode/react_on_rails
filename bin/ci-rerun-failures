#!/usr/bin/env bash
# CI Failure Re-runner
# Automatically detects failed CI jobs and re-runs them locally
# Usage:
#   bin/ci-rerun-failures          # Check current commit
#   bin/ci-rerun-failures --previous  # Search recent commits for failures
#   bin/ci-rerun-failures 1964     # Check specific PR

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Show help
show_help() {
  cat << EOF
${BLUE}CI Failure Re-runner${NC}

Automatically detects failed CI jobs from GitHub and re-runs them locally.

${YELLOW}Usage:${NC}
  bin/ci-rerun-failures [OPTIONS] [PR_NUMBER]

${YELLOW}Options:${NC}
  --previous, --prev, -p    Search recent commits for failures (when current is clean)
  --help, -h                Show this help message

${YELLOW}Examples:${NC}
  bin/ci-rerun-failures              # Check current commit
  bin/ci-rerun-failures --previous   # Find failures in recent commits
  bin/ci-rerun-failures 1964         # Check specific PR number

${YELLOW}Features:${NC}
  - Fetches actual CI failures from GitHub using gh CLI
  - Waits for in-progress CI jobs (polls every 30s)
  - Maps CI job names to local rake commands
  - Deduplicates commands
  - Shows what will run before executing

${YELLOW}Related Tools:${NC}
  bin/ci-run-failed-specs    Run specific failing RSpec examples
  bin/ci-local               Smart test detection based on code changes
EOF
  exit 0
}

# Parse arguments
USE_PREVIOUS=false
PR_NUMBER=""

while [[ $# -gt 0 ]]; do
  case $1 in
    --help|-h)
      show_help
      ;;
    --previous|--prev|-p)
      USE_PREVIOUS=true
      shift
      ;;
    *)
      PR_NUMBER="$1"
      shift
      ;;
  esac
done

echo -e "${BLUE}=== CI Failure Re-runner ===${NC}"
echo ""

# Check required dependencies
MISSING_DEPS=()
command -v gh >/dev/null 2>&1 || MISSING_DEPS+=("gh (GitHub CLI)")
command -v jq >/dev/null 2>&1 || MISSING_DEPS+=("jq")

if [ ${#MISSING_DEPS[@]} -gt 0 ]; then
  echo -e "${RED}Error: Missing required dependencies:${NC}"
  for dep in "${MISSING_DEPS[@]}"; do
    echo "  - $dep"
  done
  echo ""
  echo "Install with:"
  echo "  brew install gh jq"
  exit 1
fi

# Fetch PR info
if [ -z "$PR_NUMBER" ]; then
  if ! gh pr view --json number,commits >/dev/null 2>&1; then
    echo -e "${RED}Error: Not on a PR branch or gh CLI not authenticated${NC}"
    echo "Usage: bin/ci-rerun-failures [--previous] [pr-number]"
    exit 1
  fi
  PR_INFO=$(gh pr view --json number,commits)
  PR_NUMBER=$(echo "$PR_INFO" | jq -r '.number')
else
  if ! gh pr view "$PR_NUMBER" --json number,commits >/dev/null 2>&1; then
    echo -e "${RED}Error: PR #$PR_NUMBER not found${NC}"
    exit 1
  fi
  PR_INFO=$(gh pr view "$PR_NUMBER" --json number,commits)
fi

# Determine which commit to check
if [ "$USE_PREVIOUS" = true ]; then
  # Show recent commits and let user see which had failures
  echo -e "${BLUE}Recent commits on this PR:${NC}"
  echo "$PR_INFO" | jq -r '.commits[-5:] | reverse | .[] | "  \(.oid[0:8]) - \(.messageHeadline)"'
  echo ""

  # Check each commit from newest to oldest for failures
  FOUND_FAILURES=false
  for i in 2 3 4 5; do
    COMMIT_SHA=$(echo "$PR_INFO" | jq -r ".commits[-$i].oid // empty")
    if [ -z "$COMMIT_SHA" ]; then
      continue
    fi

    echo "Checking commit ${COMMIT_SHA:0:8}..."
    CHECK_RUNS=$(gh api "repos/{owner}/{repo}/commits/$COMMIT_SHA/check-runs" --jq '.check_runs' 2>/dev/null || echo "[]")
    FAILURE_COUNT=$(echo "$CHECK_RUNS" | jq '[.[] | select(.conclusion == "FAILURE")] | length')

    if [ "$FAILURE_COUNT" -gt 0 ]; then
      echo -e "${GREEN}Found $FAILURE_COUNT failed check(s) in commit ${COMMIT_SHA:0:8}${NC}"
      STATUS_JSON=$(echo "$CHECK_RUNS" | jq '{statusCheckRollup: [.[] | {name: .name, conclusion: .conclusion, status: .status}], number: '$PR_NUMBER'}')
      FOUND_FAILURES=true
      break
    fi
  done

  if [ "$FOUND_FAILURES" = false ]; then
    echo -e "${YELLOW}No failures found in recent commits. Using current commit.${NC}"
    STATUS_JSON=$(gh pr view "$PR_NUMBER" --json statusCheckRollup,number)
  fi
else
  # Use current commit (HEAD of PR)
  echo "Fetching current PR status..."
  STATUS_JSON=$(gh pr view "$PR_NUMBER" --json statusCheckRollup,number)
fi

echo -e "${GREEN}Analyzing PR #$PR_NUMBER...${NC}"
echo ""

# Check for in-progress jobs
IN_PROGRESS_COUNT=$(echo "$STATUS_JSON" | jq '[(.statusCheckRollup // [])[] | select(.status == "IN_PROGRESS")] | length')
if [ "$IN_PROGRESS_COUNT" -gt 0 ]; then
  echo -e "${YELLOW}â³ $IN_PROGRESS_COUNT CI jobs are still running...${NC}"
  echo ""
  read -p "Wait for CI to complete? [Y/n] " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
    echo "Waiting for CI to complete (checking every 30 seconds)..."
    while [ "$IN_PROGRESS_COUNT" -gt 0 ]; do
      sleep 30
      STATUS_JSON=$(gh pr view "$PR_NUMBER" --json statusCheckRollup,number 2>/dev/null)
      IN_PROGRESS_COUNT=$(echo "$STATUS_JSON" | jq '[(.statusCheckRollup // [])[] | select(.status == "IN_PROGRESS")] | length')
      FAILED_COUNT=$(echo "$STATUS_JSON" | jq '[(.statusCheckRollup // [])[] | select(.conclusion == "FAILURE")] | length')
      echo -e "  In progress: $IN_PROGRESS_COUNT | Failed: $FAILED_COUNT"
    done
    echo -e "${GREEN}âœ“ CI completed!${NC}"
    echo ""
  fi
fi

# Parse failed checks
FAILED_CHECKS=$(echo "$STATUS_JSON" | jq -r '(.statusCheckRollup // [])[] | select(.conclusion == "FAILURE") | .name')

if [ -z "$FAILED_CHECKS" ]; then
  echo -e "${GREEN}âœ“ No failed checks found! All CI jobs passed.${NC}"
  exit 0
fi

echo -e "${YELLOW}Failed CI jobs:${NC}"
echo "$FAILED_CHECKS" | while read -r check; do
  # Try to get version info for the check
  version_info=""
  for job_name in "${!JOB_VERSION_MAP[@]}"; do
    if [[ "$check" == "$job_name"* ]]; then
      version_info=" (${JOB_VERSION_MAP[$job_name]})"
      break
    fi
  done
  echo -e "${RED}  âœ— $check${version_info}${NC}"
done
echo ""

# Map CI job names to local commands with version info
declare -A JOB_MAP
JOB_MAP["lint-js-and-ruby"]="bundle exec rubocop && yarn run eslint --report-unused-disable-directives && yarn start format.listDifferent"
JOB_MAP["rspec-package-tests"]="bundle exec rake run_rspec:gem"
JOB_MAP["package-js-tests"]="yarn test"
JOB_MAP["dummy-app-integration-tests (3.4, 22, latest)"]="bundle exec rake run_rspec:all_dummy"
JOB_MAP["dummy-app-integration-tests (3.2, 20, minimum)"]="bundle exec rake run_rspec:all_dummy"
JOB_MAP["examples"]="bundle exec rake run_rspec:shakapacker_examples"

# Map CI job names to human-readable versions
declare -A JOB_VERSION_MAP
JOB_VERSION_MAP["dummy-app-integration-tests (3.4, 22, latest)"]="Ruby 3.4, Node 22, Shakapacker 9.3.0, React 19"
JOB_VERSION_MAP["dummy-app-integration-tests (3.2, 20, minimum)"]="Ruby 3.2, Node 20, Shakapacker 8.2.0, React 18"

# Track what we'll run (deduplicated)
declare -A COMMANDS_TO_RUN

while IFS= read -r check; do
  for job_name in "${!JOB_MAP[@]}"; do
    if [[ "$check" == "$job_name"* ]]; then
      COMMANDS_TO_RUN["${JOB_MAP[$job_name]}"]="$job_name"
      break
    fi
  done
done <<< "$FAILED_CHECKS"

# Check if any commands were found (handle empty array with set -u)
set +u
NUM_COMMANDS=${#COMMANDS_TO_RUN[@]}
set -u

if [ "$NUM_COMMANDS" -eq 0 ]; then
  echo -e "${YELLOW}No local equivalents found for failed jobs.${NC}"
  echo "Failed jobs might be from Pro or other workflows."
  echo ""
  echo "You can still run common test suites:"
  echo "  bundle exec rake run_rspec:all_dummy    # Dummy app tests"
  echo "  bundle exec rake run_rspec:gem          # Gem tests"
  echo "  yarn test                                 # JS tests"
  exit 1
fi

echo -e "${BLUE}Will run the following commands:${NC}"
for cmd in "${!COMMANDS_TO_RUN[@]}"; do
  job_name="${COMMANDS_TO_RUN[$cmd]}"
  # Try to get version info for the job
  version_info=""
  for mapped_job_name in "${!JOB_VERSION_MAP[@]}"; do
    if [[ "$job_name" == "$mapped_job_name"* ]]; then
      version_info=" (${JOB_VERSION_MAP[$mapped_job_name]})"
      break
    fi
  done
  echo -e "${BLUE}  â€¢ $job_name${version_info}:${NC} $cmd"
done
echo ""

# Offer to show GitHub Actions logs for more specific failures
echo -e "${YELLOW}ðŸ’¡ Tip: For RSpec failures, you can run specific failing examples:${NC}"
echo "   1. Go to the failed job on GitHub Actions"
echo "   2. Copy the 'Failed examples:' section"
echo "   3. Run: pbpaste | bin/ci-run-failed-specs"
echo ""

# Confirm before running
read -p "Run these tests now? [Y/n] " -n 1 -r REPLY
echo
if [[ ! "${REPLY}" =~ ^[Yy]$ ]] && [[ ! -z "${REPLY}" ]]; then
  echo "Cancelled."
  exit 0
fi

echo ""

# Ensure dependencies
if [ ! -d "node_modules" ] || [ ! -d "vendor/bundle" ]; then
  echo -e "${YELLOW}Installing dependencies...${NC}"
  bundle install && yarn install
  echo ""
fi

# Run commands
FAILED_COMMANDS=()

for cmd in "${!COMMANDS_TO_RUN[@]}"; do
  job_name="${COMMANDS_TO_RUN[$cmd]}"
  # Try to get version info for the job
  version_info=""
  for mapped_job_name in "${!JOB_VERSION_MAP[@]}"; do
    if [[ "$job_name" == "$mapped_job_name"* ]]; then
      version_info=" (${JOB_VERSION_MAP[$mapped_job_name]})"
      break
    fi
  done

  echo -e "${BLUE}â–¶ Running: $job_name${version_info}${NC}"
  echo -e "${BLUE}Command: $cmd${NC}"
  echo ""

  # Note: Using eval here is safe because $cmd comes from predefined JOB_MAP,
  # not from user input. Commands may contain shell operators like && and ||.
  if eval "$cmd"; then
    echo -e "${GREEN}âœ“ $job_name${version_info} passed${NC}"
    echo ""
  else
    echo -e "${RED}âœ— $job_name${version_info} failed${NC}"
    echo ""
    FAILED_COMMANDS+=("$job_name$version_info")
  fi
done

# Summary
echo ""
echo -e "${BLUE}=== Summary ===${NC}"

if [ ${#FAILED_COMMANDS[@]} -eq 0 ]; then
  echo -e "${GREEN}All local tests passed! âœ“${NC}"
  echo ""
  echo "Push your changes and CI should pass."
  exit 0
else
  echo -e "${RED}Some tests still failing:${NC}"
  for cmd in "${FAILED_COMMANDS[@]}"; do
    echo -e "${RED}  âœ— $cmd${NC}"
  done
  echo ""
  echo -e "${YELLOW}Fix these failures before pushing.${NC}"
  exit 1
fi
