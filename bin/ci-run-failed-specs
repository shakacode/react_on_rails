#!/usr/bin/env bash
# Run specific failed RSpec examples
# Usage:
#   bin/ci-run-failed-specs './spec/system/integration_spec.rb[1:1:1:1]' './spec/system/integration_spec.rb[10:1]'
#
#   Or pipe from GitHub Actions output:
#   pbpaste | bin/ci-run-failed-specs
#
#   Or read from rspec failure output file:
#   bin/ci-run-failed-specs < failures.txt

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Check required dependencies
MISSING_DEPS=()
command -v bundle >/dev/null 2>&1 || MISSING_DEPS+=("bundle (Ruby bundler)")

if [ ${#MISSING_DEPS[@]} -gt 0 ]; then
  echo -e "${RED}Error: Missing required dependencies:${NC}"
  for dep in "${MISSING_DEPS[@]}"; do
    echo "  - $dep"
  done
  echo ""
  echo "Install with:"
  echo "  gem install bundler"
  exit 1
fi

# Show help
show_help() {
  cat << EOF
${BLUE}Failed Spec Runner${NC}

Run only the specific RSpec examples that failed in CI.

${YELLOW}Usage:${NC}
  bin/ci-run-failed-specs [OPTIONS] [SPEC_PATHS...]
  pbpaste | bin/ci-run-failed-specs
  bin/ci-run-failed-specs < failures.txt

${YELLOW}Options:${NC}
  --help, -h    Show this help message

${YELLOW}Examples:${NC}
  # Pass spec paths directly
  bin/ci-run-failed-specs './spec/system/integration_spec.rb[1:1:1:1]'

  # Copy from GitHub Actions, paste to run
  pbpaste | bin/ci-run-failed-specs

  # From file
  bin/ci-run-failed-specs < failures.txt

  # Multiple specs
  bin/ci-run-failed-specs './spec/system/integration_spec.rb[1:1:1:1]' './spec/system/integration_spec.rb[10:1]'

${YELLOW}Features:${NC}
  - Parses RSpec failure output automatically
  - Extracts spec paths from "rspec ./spec/..." lines
  - Deduplicates specs
  - Auto-detects working directory (runs from spec/dummy when needed)
  - Confirms before running

${YELLOW}Workflow:${NC}
  1. Go to failed job on GitHub Actions
  2. Copy the "Failed examples:" section
  3. Run: pbpaste | bin/ci-run-failed-specs
  4. Tests run only for those specific failures

${YELLOW}Related Tools:${NC}
  bin/ci-rerun-failures    Auto-detect and re-run failed CI jobs
  bin/ci-local             Smart test detection based on code changes
EOF
  exit 0
}

echo -e "${BLUE}=== Failed Spec Runner ===${NC}"
echo ""

# Check for help flag
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
  show_help
fi

# Collect spec paths
SPECS=()

# If arguments provided, use them
if [ $# -gt 0 ]; then
  SPECS=("$@")
else
  # Read from stdin (piped or redirected input)
  echo "Reading failed specs from stdin..."
  echo "Paste RSpec failure output (Ctrl+D when done):"

  while IFS= read -r line; do
    # Extract rspec commands from lines like "rspec ./spec/foo.rb[1:2:3]"
    if [[ "$line" =~ rspec[[:space:]]+(\./spec/[^[:space:]]+) ]]; then
      spec="${BASH_REMATCH[1]}"
      SPECS+=("$spec")
    # Also handle bare spec paths like "spec/foo.rb[1:2:3]" or "./spec/foo.rb[1:2:3]"
    # Strip trailing % and whitespace
    elif [[ "$line" =~ (\.?/?spec/[^[:space:]%]+) ]]; then
      spec="${BASH_REMATCH[1]}"
      # Normalize to ./spec/ format
      if [[ ! "$spec" =~ ^\. ]]; then
        spec="./$spec"
      fi
      SPECS+=("$spec")
    fi
  done
fi

if [ ${#SPECS[@]} -eq 0 ]; then
  echo -e "${RED}No specs found!${NC}"
  echo ""
  echo "Usage examples:"
  echo "  bin/ci-run-failed-specs './spec/system/integration_spec.rb[1:1:1:1]'"
  echo "  pbpaste | bin/ci-run-failed-specs"
  echo "  bin/ci-run-failed-specs < failures.txt"
  exit 1
fi

# Deduplicate specs
UNIQUE_SPECS=($(printf '%s\n' "${SPECS[@]}" | sort -u))

echo -e "${GREEN}Found ${#UNIQUE_SPECS[@]} unique failing spec(s):${NC}"
for spec in "${UNIQUE_SPECS[@]}"; do
  echo -e "  ${YELLOW}✗${NC} $spec"
done
echo ""

# Determine the working directory (check if we need to be in spec/dummy)
WORKING_DIR="."
if [[ "${UNIQUE_SPECS[0]}" == *"spec/system"* ]] || [[ "${UNIQUE_SPECS[0]}" == *"spec/helpers"* ]]; then
  if [ -d "spec/dummy" ]; then
    WORKING_DIR="spec/dummy"
    echo -e "${BLUE}Running from spec/dummy directory${NC}"
  fi
fi

# Build rspec command as array (safer than eval)
RSPEC_CMD=("bundle" "exec" "rspec")
for spec in "${UNIQUE_SPECS[@]}"; do
  RSPEC_CMD+=("$spec")
done

# Display command for user
DISPLAY_CMD="bundle exec rspec"
for spec in "${UNIQUE_SPECS[@]}"; do
  DISPLAY_CMD="$DISPLAY_CMD '$spec'"
done
echo -e "${BLUE}Command:${NC} cd $WORKING_DIR && $DISPLAY_CMD"
echo ""

# Confirm (read from /dev/tty to handle piped input)
if [ -t 0 ]; then
  # stdin is a TTY, read directly
  read -p "Run these specs now? [Y/n] " -n 1 -r REPLY
else
  # stdin is not a TTY (piped input), try /dev/tty
  # Check if we can actually open /dev/tty by attempting to use it in a subshell
  set +e  # Temporarily disable errexit for the check
  (exec 0</dev/tty) 2>/dev/null
  TTY_CHECK=$?
  set -e  # Re-enable errexit

  if [ $TTY_CHECK -eq 0 ]; then
    # Successfully opened /dev/tty, use it for confirmation
    read -p "Run these specs now? [Y/n] " -n 1 -r REPLY < /dev/tty
  else
    # Cannot open /dev/tty, auto-confirm
    echo "Run these specs now? [Y/n] Y (auto-confirmed, TTY unavailable)"
    REPLY="Y"
  fi
fi
echo
if [[ ! "${REPLY}" =~ ^[Yy]$ ]] && [[ ! -z "${REPLY}" ]]; then
  echo "Cancelled."
  exit 0
fi

# Run the specs directly (no eval - safer)
cd "$WORKING_DIR"
"${RSPEC_CMD[@]}"
RESULT=$?

echo ""
if [ $RESULT -eq 0 ]; then
  echo -e "${GREEN}✓ All specs passed!${NC}"
else
  echo -e "${RED}✗ Some specs failed (exit code: $RESULT)${NC}"
fi

exit $RESULT
