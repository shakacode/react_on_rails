name: Ensure master docs-only skips are safe
description: Fails if the previous master commit still has failing workflow runs when current push is docs-only
inputs:
  docs-only:
    description: 'String output from ci-changes-detector ("true" or "false")'
    required: true
  previous-sha:
    description: 'SHA of the previous commit on master (github.event.before)'
    required: true
runs:
  using: composite
  steps:
    - name: Check previous master commit status
      if: ${{ inputs.docs-only == 'true' && inputs.previous-sha != '' && inputs.previous-sha != '0000000000000000000000000000000000000000' }}
      uses: actions/github-script@v7
      env:
        PREVIOUS_SHA: ${{ inputs.previous-sha }}
      with:
        script: |
          const previousSha = process.env.PREVIOUS_SHA;

          // Query workflow runs from the last 7 days to avoid excessive API calls.
          // Why 7 days? This balances API efficiency with practical needs:
          // - Most master commits trigger CI within hours, not days
          // - Commits older than 7 days are likely stale; better to run full CI anyway
          // - Reduces pagination load on high-velocity repos
          // For commits outside this window, we skip the check and allow the docs-only skip.
          const createdAfter = new Date(Date.now() - 1000 * 60 * 60 * 24 * 7).toISOString();

          // Optimize pagination: use lower per_page and collect only what we need
          const workflowRuns = [];
          let foundAllRelevant = false;

          for await (const response of github.paginate.iterator(
            github.rest.actions.listWorkflowRunsForRepo,
            {
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'master',
              event: 'push',
              per_page: 30,
              created: `>${createdAfter}`
            }
          )) {
            const pageRuns = response.data;
            const relevantInPage = pageRuns.filter((run) => run.head_sha === previousSha);

            if (relevantInPage.length > 0) {
              workflowRuns.push(...relevantInPage);
            }

            // Early exit: if we found relevant runs and now seeing different SHAs,
            // we've likely collected all runs for the previous commit
            if (workflowRuns.length > 0 && relevantInPage.length === 0) {
              foundAllRelevant = true;
              break;
            }
          }

          if (workflowRuns.length === 0) {
            core.info(`No workflow runs found for ${previousSha} in the last 7 days. Allowing docs-only skip.`);
            return;
          }

          // Deduplicate workflow runs by keeping only the latest run for each workflow_id.
          // This handles cases where workflows are re-run manually.
          // Use run_number as tiebreaker since created_at might be identical for rapid reruns.
          const latestByWorkflow = new Map();
          for (const run of workflowRuns) {
            const existing = latestByWorkflow.get(run.workflow_id);
            if (!existing || run.run_number > existing.run_number) {
              latestByWorkflow.set(run.workflow_id, run);
            }
          }

          // Check for workflows that are still running
          // We require all workflows to complete before allowing docs-only skip
          // This prevents skipping CI when the previous commit hasn't been fully validated
          const incompleteRuns = Array.from(latestByWorkflow.values()).filter(
            (run) => run.status !== 'completed'
          );

          if (incompleteRuns.length > 0) {
            const details = incompleteRuns
              .map((run) => `- [${run.name} #${run.run_number}](${run.html_url}) is still ${run.status}`)
              .join('\n');
            core.setFailed(
              [
                `Cannot skip CI for docs-only commit because previous master commit ${previousSha} still has running workflows:`,
                details,
                '',
                'Wait for these workflows to complete before pushing docs-only changes.'
              ].join('\n')
            );
            return;
          }

          // Check for workflows that failed on the previous commit.
          // We treat these conclusions as failures:
          // - 'failure': Obvious failure case
          // - 'timed_out': Infrastructure or performance issue that should be investigated
          // - 'cancelled': Conservative - might indicate timeout or manual intervention needed
          // - 'action_required': Requires manual intervention
          // We treat 'skipped' and 'neutral' as non-blocking since they indicate
          // intentional skips or informational-only workflows.
          const failingRuns = Array.from(latestByWorkflow.values()).filter((run) => {
            return ['failure', 'timed_out', 'cancelled', 'action_required'].includes(run.conclusion);
          });

          if (failingRuns.length === 0) {
            core.info(`Previous master commit ${previousSha} completed without failures. Docs-only skip allowed.`);
            return;
          }

          const details = failingRuns
            .map((run) => `- [${run.name} #${run.run_number}](${run.html_url}) concluded ${run.conclusion}`)
            .join('\n');

          core.setFailed(
            [
              `Cannot skip CI for docs-only commit because previous master commit ${previousSha} still has failing workflows:`,
              details,
              '',
              'Fix these failures before pushing docs-only changes, or push non-docs changes to trigger full CI.'
            ].join('\n')
          );
