name: Run Full CI Suite

on:
  issue_comment:
    types: [created]

# Prevent concurrent runs per PR
concurrency:
  group: full-ci-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  trigger-full-ci:
    # Only run on PR comments that match the command
    if: |
      github.event.issue.pull_request &&
      (
        startsWith(github.event.comment.body, '/run-skipped-ci') ||
        contains(github.event.comment.body, '\n/run-skipped-ci')
      )
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      pull-requests: write
      actions: write
    steps:
      - name: Check if user has write access
        id: check_access
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: context.actor
              });

              const hasAccess = ['admin', 'write'].includes(permission.permission);
              console.log(`User ${context.actor} has permission: ${permission.permission}`);

              if (!hasAccess) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: `@${context.actor} Sorry, only repository collaborators with write access can trigger full CI runs. ðŸ”’`
                });
              }

              return hasAccess;
            } catch (error) {
              console.error('Error checking permissions:', error);
              return false;
            }

      - name: Exit if no access
        if: steps.check_access.outputs.result == 'false'
        run: |
          echo "User does not have permission to trigger full CI"
          exit 1

      - name: Add reaction to comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          comment-id: ${{ github.event.comment.id }}
          reactions: 'rocket'

      - name: Get PR details
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            return {
              ref: pr.data.head.ref,
              sha: pr.data.head.sha
            };

      - name: Trigger all workflows and collect results
        id: trigger_workflows
        uses: actions/github-script@v7
        with:
          script: |
            const prData = ${{ steps.pr.outputs.result }};

            // Workflows that support minimum dependency testing
            const workflowsWithMinimum = [
              { id: 'main.yml', name: 'Main Tests' },
              { id: 'examples.yml', name: 'Generator Tests' }
            ];

            // Pro workflows always run (no minimum matrix)
            const proWorkflows = [
              { id: 'pro-integration-tests.yml', name: 'Pro Integration Tests' },
              { id: 'pro-package-tests.yml', name: 'Pro Package Tests' }
            ];

            const succeeded = [];
            const failed = [];
            const skipped = [];

            // Trigger workflows with minimum dependency testing
            for (const workflow of workflowsWithMinimum) {
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.id,
                  ref: prData.ref,
                  inputs: {
                    run_minimum_tests: 'true'
                  }
                });
                console.log(`âœ… Triggered ${workflow.id} with run_minimum_tests=true`);
                succeeded.push(workflow);
              } catch (error) {
                console.error(`âŒ Failed to trigger ${workflow.id}:`, error.message);
                failed.push({ workflow: workflow.name, error: error.message });
              }
            }

            // Skip Pro workflows (they don't have minimum matrix, always run on PRs if needed)
            for (const workflow of proWorkflows) {
              console.log(`â­ï¸  Skipping ${workflow.id} (no minimum dependency matrix)`);
              skipped.push(workflow);
            }

            // Wait a bit for workflows to queue
            if (succeeded.length > 0) {
              console.log('Waiting 5 seconds for workflows to queue...');
              await new Promise(resolve => setTimeout(resolve, 5000));
            }

            // Verify workflows are queued/running
            const verified = [];
            const notFound = [];

            if (succeeded.length > 0) {
              const runs = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100,
                created: `>${new Date(Date.now() - 60000).toISOString()}`
              });

              for (const workflow of succeeded) {
                const found = runs.data.workflow_runs.some(run =>
                  run.path === `.github/workflows/${workflow.id}` &&
                  run.head_sha === prData.sha &&
                  run.event === 'workflow_dispatch'
                );

                if (found) {
                  verified.push(workflow);
                } else {
                  notFound.push(workflow);
                }
              }
            }

            // Build the comment body based on actual results
            let status = 'âœ… **Successfully triggered skipped CI tests**';
            if (failed.length > 0 && notFound.length > 0) {
              status = 'âŒ **Failed to trigger or verify workflows**';
            } else if (failed.length > 0) {
              status = 'âš ï¸ **Some workflows failed to trigger**';
            } else if (notFound.length > 0) {
              status = 'âš ï¸ **Workflows triggered but not yet verified**';
            }

            const verifiedList = verified.length > 0 ? verified.map(w => `- âœ… ${w.name}`).join('\n') : '';
            const notFoundList = notFound.length > 0 ? `\n\n**Triggered but not yet queued (may still start):**\n${notFound.map(w => `- â³ ${w.name}`).join('\n')}` : '';
            const failedList = failed.length > 0 ? `\n\n**Failed to trigger:**\n${failed.map(f => `- âŒ ${f.workflow}: ${f.error}`).join('\n')}` : '';
            const skippedList = skipped.length > 0 ? `\n\n**Skipped (already run on PRs):**\n${skipped.map(w => `- â­ï¸  ${w.name}`).join('\n')}` : '';

            const body = `ðŸš€ **Skipped CI Tests Triggered**

            ${status}

            ${verifiedList ? `**Running minimum dependency tests:**\n${verifiedList}` : ''}${notFoundList}${failedList}${skippedList}

            ${verified.length > 0 ? `\n**What's running:**
            - âœ… Minimum dependency versions (Ruby 3.2, Node 20)
            - âœ… Generator tests with minimum dependencies

            **Note:** Pro package tests and latest dependency tests are skipped because they already run on all PRs.

            View progress in the [Actions tab](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions).` : ''}`;

            // Post the comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

            // Fail the job if any workflows failed to trigger
            if (failed.length > 0) {
              core.setFailed(`Failed to trigger ${failed.length} workflow(s): ${failed.map(f => f.workflow).join(', ')}`);
            }
