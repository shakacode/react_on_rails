#!/usr/bin/env ruby
# frozen_string_literal: true

require "English"

def installed?(process)
  IO.popen "#{process} -v"
rescue Errno::ENOENT
  false
end

def generate_packs
  puts "üì¶ Generating React on Rails packs..."
  system "bundle exec rake react_on_rails:generate_packs"

  return if $CHILD_STATUS.success?

  puts "‚ùå Pack generation failed"
  exit 1
end

def ensure_procfile(procfile)
  return if File.exist?(procfile)

  warn <<~MSG
    ERROR:
    Please ensure `#{procfile}` exists in your project!
  MSG
  exit 1
end

def cleanup_stale_sockets
  # Check for stale overmind socket files
  socket_files = [".overmind.sock", "tmp/sockets/overmind.sock"]

  # Only clean up if overmind is not actually running
  overmind_pids = `pgrep -f "overmind" 2>/dev/null`.split("\n").map(&:to_i)

  if overmind_pids.empty?
    socket_files.each do |socket_file|
      if File.exist?(socket_file)
        puts "   üßπ Cleaning up stale socket: #{socket_file}"
        File.delete(socket_file) rescue nil
      end
    end
  end
end

def run_with_process_manager(procfile)
  # Clean up stale sockets before starting
  cleanup_stale_sockets

  if installed?("overmind")
    system "overmind start -f #{procfile}"
  elsif installed?("foreman")
    system "foreman start -f #{procfile}"
  else
    warn <<~MSG
      NOTICE:
      For this script to run, you need either 'overmind' or 'foreman' installed on your machine. Please try this script after installing one of them.
    MSG
    exit 1
  end
end

def print_server_info(title, features, port = 3000)
  puts "#{title}"
  features.each { |feature| puts "   - #{feature}" }
  puts ""
  puts "üí° Access at: http://localhost:#{port}"
  puts ""
end

def run_production_like
  print_server_info(
    "üè≠ Starting production-like development server...",
    [
      "Generating React on Rails packs",
      "Precompiling assets with production optimizations",
      "Running Rails server on port 3001",
      "No HMR (Hot Module Replacement)",
      "CSS extracted to separate files (no FOUC)"
    ],
    3001
  )

  generate_packs

  # Precompile assets in production mode
  puts "üî® Precompiling assets..."
  system "RAILS_ENV=production NODE_ENV=production bundle exec rails assets:precompile"

  if $CHILD_STATUS.success?
    puts "‚úÖ Assets precompiled successfully"
    puts "üöÄ Starting Rails server in production mode..."
    puts ""
    puts "Press Ctrl+C to stop the server"
    puts "To clean up: rm -rf public/packs && bin/dev"
    puts ""

    # Start Rails in production mode
    system "RAILS_ENV=production bundle exec rails server -p 3001"
  else
    puts "‚ùå Asset precompilation failed"
    exit 1
  end
end

def run_static_development
  print_server_info(
    "‚ö° Starting development server with static assets...",
    [
      "Generating React on Rails packs",
      "Using shakapacker --watch (no HMR)",
      "CSS extracted to separate files (no FOUC)",
      "Development environment (source maps, faster builds)",
      "Auto-recompiles on file changes"
    ]
  )

  generate_packs

  procfile = "Procfile.dev-static-assets"
  ensure_procfile(procfile)
  run_with_process_manager(procfile)
end

def run_development
  generate_packs

  procfile = "Procfile.dev"
  ensure_procfile(procfile)
  run_with_process_manager(procfile)
end

def kill_processes
  puts "üî™ Killing all development processes..."
  puts ""

  processes = {
    "rails" => "Rails server",
    "node.*react[-_]on[-_]rails" => "React on Rails Node processes",
    "overmind" => "Overmind process manager",
    "foreman" => "Foreman process manager",
    "ruby.*puma" => "Puma server",
    "webpack-dev-server" => "Webpack dev server",
    "bin/shakapacker-dev-server" => "Shakapacker dev server"
  }

  killed_any = false

  processes.each do |pattern, description|
    pids = `pgrep -f "#{pattern}" 2>/dev/null`.split("\n").map(&:to_i).reject { |pid| pid == Process.pid }

    if pids.any?
      puts "   ‚ò†Ô∏è  Killing #{description} (PIDs: #{pids.join(', ')})"
      pids.each { |pid| Process.kill("TERM", pid) rescue nil }
      killed_any = true
    end
  end

  # Clean up socket files
  socket_files = [".overmind.sock", "tmp/sockets/overmind.sock"]
  socket_files.each do |socket_file|
    if File.exist?(socket_file)
      puts "   üßπ Removing #{socket_file}"
      File.delete(socket_file) rescue nil
      killed_any = true
    end
  end

  if killed_any
    puts ""
    puts "‚úÖ All processes terminated and sockets cleaned"
    puts "üí° You can now run 'bin/dev' for a clean start"
  else
    puts "   ‚ÑπÔ∏è  No development processes found running"
  end
end

def show_help
  puts <<~HELP
    Usage: bin/dev [command]

    Commands:
      (none) / hmr        Start development server with HMR (default)
      static              Start development server with static assets (no HMR, no FOUC)
      production-assets   Start with production-optimized assets (no HMR)
      prod                Alias for production-assets
      kill                Kill all development processes for a clean start
      help                Show this help message
    #{'  '}
    HMR Development mode (default):
    ‚Ä¢ Hot Module Replacement (HMR) enabled
    ‚Ä¢ Automatic React on Rails pack generation
    ‚Ä¢ Source maps for debugging
    ‚Ä¢ May have Flash of Unstyled Content (FOUC)
    ‚Ä¢ Fast recompilation
    ‚Ä¢ Access at: http://localhost:3000

    Static development mode:
    ‚Ä¢ No HMR (static assets with auto-recompilation)
    ‚Ä¢ Automatic React on Rails pack generation
    ‚Ä¢ CSS extracted to separate files (no FOUC)
    ‚Ä¢ Development environment (faster builds than production)
    ‚Ä¢ Source maps for debugging
    ‚Ä¢ Access at: http://localhost:3000

    Production-assets mode:
    ‚Ä¢ Automatic React on Rails pack generation
    ‚Ä¢ Optimized, minified bundles
    ‚Ä¢ Extracted CSS files (no FOUC)
    ‚Ä¢ No HMR (static assets)
    ‚Ä¢ Slower recompilation
    ‚Ä¢ Access at: http://localhost:3001
  HELP
end

# Main execution
case ARGV[0]
when "production-assets", "prod"
  run_production_like
when "static"
  run_static_development
when "kill"
  kill_processes
when "help", "--help", "-h"
  show_help
when "hmr", nil
  run_development
else
  puts "Unknown argument: #{ARGV[0]}"
  puts "Run 'bin/dev help' for usage information"
  exit 1
end
