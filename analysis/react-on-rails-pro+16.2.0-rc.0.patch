--- a/node_modules/react-on-rails-pro/lib/ClientSideRenderer.js
+++ b/node_modules/react-on-rails-pro/lib/ClientSideRenderer.js
@@ -20,6 +20,83 @@
 import { onPageLoaded } from 'react-on-rails/pageLifecycle';
 import * as StoreRegistry from "./StoreRegistry.js";
 import * as ComponentRegistry from "./ComponentRegistry.js";
+
+// ============================================================================
+// DIAGNOSTIC PATCH: Enhanced JSON parsing with detailed error reporting
+// This patch helps diagnose the non-deterministic JSON parsing issue (#2283)
+// https://github.com/shakacode/react_on_rails/issues/2283
+// ============================================================================
+function parsePropsWithDiagnostics(textContent, element, context) {
+    if (textContent === null) {
+        return {};
+    }
+    try {
+        return JSON.parse(textContent);
+    } catch (originalError) {
+        const diagnostics = {
+            context: context,
+            timestamp: new Date().toISOString(),
+            textContentLength: textContent.length,
+            textContentFirst200: textContent.slice(0, 200),
+            textContentLast200: textContent.slice(-200),
+            elementConnected: element ? element.isConnected : 'element is null',
+            elementTagName: element ? element.tagName : 'N/A',
+            elementId: element ? element.id : 'N/A',
+            documentReadyState: document.readyState,
+            originalError: originalError.message,
+        };
+        const positionMatch = originalError.message.match(/position (\d+)/);
+        if (positionMatch) {
+            const position = parseInt(positionMatch[1], 10);
+            diagnostics.errorPosition = position;
+            const start = Math.max(0, position - 100);
+            const end = Math.min(textContent.length, position + 100);
+            diagnostics.contentAroundError = textContent.slice(start, end);
+            diagnostics.charAtPosition = textContent.charCodeAt(position);
+            diagnostics.charBeforePosition = position > 0 ? textContent.charCodeAt(position - 1) : 'N/A';
+            diagnostics.nearErrorContent = textContent.slice(Math.max(0, position - 20), position + 20);
+            if (position === textContent.length || position === textContent.length - 1) {
+                diagnostics.likelyTruncation = true;
+            }
+        }
+        if (textContent.includes('&quot;') || textContent.includes('&lt;') || textContent.includes('&gt;') || textContent.includes('&amp;')) {
+            diagnostics.hasHtmlEntities = true;
+            diagnostics.htmlEntitySamples = {
+                quot: (textContent.match(/&quot;/g) || []).length,
+                lt: (textContent.match(/&lt;/g) || []).length,
+                gt: (textContent.match(/&gt;/g) || []).length,
+                amp: (textContent.match(/&amp;/g) || []).length,
+            };
+        }
+        const nullByteIndex = textContent.indexOf('\0');
+        if (nullByteIndex !== -1) {
+            diagnostics.hasNullByte = true;
+            diagnostics.nullBytePosition = nullByteIndex;
+        }
+        console.error('[ReactOnRails Pro] JSON Parse Diagnostics:', diagnostics);
+        const enhancedError = new Error(
+            `[ReactOnRails Pro JSON Parse Error] ${originalError.message}\n` +
+            `Context: ${context}\n` +
+            `Content length: ${diagnostics.textContentLength}\n` +
+            `Element connected: ${diagnostics.elementConnected}\n` +
+            `Document ready state: ${diagnostics.documentReadyState}\n` +
+            `First 200 chars: ${diagnostics.textContentFirst200}\n` +
+            `Last 200 chars: ${diagnostics.textContentLast200}\n` +
+            (diagnostics.contentAroundError ? `Content around error: ${diagnostics.contentAroundError}\n` : '') +
+            (diagnostics.likelyTruncation ? `LIKELY TRUNCATION DETECTED\n` : '') +
+            (diagnostics.hasHtmlEntities ? `WARNING: HTML entities found in JSON (quot: ${diagnostics.htmlEntitySamples.quot})\n` : '') +
+            (diagnostics.hasNullByte ? `WARNING: Null byte found at position ${diagnostics.nullBytePosition}\n` : '') +
+            `Full diagnostics: ${JSON.stringify(diagnostics)}`
+        );
+        enhancedError.stack = originalError.stack;
+        enhancedError.diagnostics = diagnostics;
+        throw enhancedError;
+    }
+}
+// ============================================================================
+// END DIAGNOSTIC PATCH
+// ============================================================================
+
 const REACT_ON_RAILS_STORE_ATTRIBUTE = 'data-js-react-on-rails-store';
 const IMMEDIATE_HYDRATION_PRO_WARNING = "[REACT ON RAILS] The 'immediate_hydration' feature requires a React on Rails Pro license. " +
     'Please visit https://shakacode.com/react-on-rails-pro to get a license.';
@@ -77,7 +154,8 @@
         // This must match lib/react_on_rails/helper.rb
         const name = el.getAttribute('data-component-name') || '';
         const { domNodeId } = this;
-        const props = el.textContent !== null ? JSON.parse(el.textContent) : {};
+        // PATCHED: Use diagnostic wrapper instead of direct JSON.parse
+        const props = parsePropsWithDiagnostics(el.textContent, el, `ComponentRenderer.render(${name}, ${domNodeId})`);
         const trace = el.getAttribute('data-trace') === 'true';
         try {
             const domNode = document.getElementById(domNodeId);
@@ -161,9 +239,8 @@
             return;
         }
         const name = storeDataElement.getAttribute(REACT_ON_RAILS_STORE_ATTRIBUTE) || '';
-        const props = storeDataElement.textContent !== null
-            ? JSON.parse(storeDataElement.textContent)
-            : {};
+        // PATCHED: Use diagnostic wrapper instead of direct JSON.parse
+        const props = parsePropsWithDiagnostics(storeDataElement.textContent, storeDataElement, `StoreRenderer(${name})`);
         this.hydratePromise = this.hydrate(railsContext, name, props);
     }
     async hydrate(railsContext, name, props) {
