<!DOCTYPE html>
<html>
<head>
  <title>JSON Race Condition Demo (Static)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 40px auto; padding: 0 20px; }
    .success { color: green; font-weight: bold; }
    .error { color: red; font-weight: bold; }
    .warning { color: orange; }
    code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }
    pre { background: #f4f4f4; padding: 10px; overflow-x: auto; }
    #result { padding: 20px; border: 2px solid #ccc; margin: 20px 0; border-radius: 8px; }
  </style>
</head>
<body>
  <h1>JSON Race Condition Demo</h1>

  <div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
    <strong>⚠️ To reproduce the bug:</strong>
    <ol style="margin-bottom: 0;">
      <li>Serve this file from the Ruby server: <code>ruby server.rb</code></li>
      <li>Open Chrome DevTools → Network tab</li>
      <li>Set throttling to <strong>"Slow 3G"</strong></li>
      <li>Refresh the page</li>
    </ol>
    <p style="margin-bottom: 0;"><em>This static HTML version may not trigger the bug because the JSON is small. Use server.rb for the full demo.</em></p>
  </div>

  <div id="result">
    <span class="warning">⏳ Waiting for script to execute...</span>
  </div>

  <!-- Component placeholder (like React on Rails renders) -->
  <div id="MyComponent-react-component-0"></div>

  <!--
    CRITICAL: This script executes IMMEDIATELY when the browser parses it.
    In immediate_hydration mode, React on Rails does the same thing.

    The race condition occurs when:
    1. This script runs
    2. But the JSON script tag below hasn't fully loaded yet
    3. textContent returns truncated JSON
    4. JSON.parse() fails
  -->
  <script>
    (function() {
      const startTime = performance.now();

      function tryParseProps() {
        const scriptEl = document.getElementById('js-react-on-rails-component-MyComponent-0');
        const resultEl = document.getElementById('result');

        if (!scriptEl) {
          resultEl.innerHTML = '<span class="warning">⏳ JSON script tag not found yet...</span>';
          setTimeout(tryParseProps, 5);
          return;
        }

        const textContent = scriptEl.textContent;
        const elapsed = (performance.now() - startTime).toFixed(2);

        try {
          const props = JSON.parse(textContent);
          resultEl.innerHTML =
            '<span class="success">✓ SUCCESS</span><br>' +
            'Parsed ' + (props.items ? props.items.length : 0) + ' items<br>' +
            'JSON size: ' + (textContent.length / 1024).toFixed(2) + ' KB<br>' +
            'Time: ' + elapsed + 'ms';
        } catch (e) {
          // THIS IS THE BUG!
          resultEl.innerHTML =
            '<span class="error">✗ JSON PARSE ERROR</span><br>' +
            '<strong>Error:</strong> ' + e.message + '<br>' +
            '<strong>textContent length:</strong> ' + textContent.length + ' bytes<br>' +
            '<strong>Time:</strong> ' + elapsed + 'ms<br><br>' +
            '<strong>Last 200 characters:</strong><br>' +
            '<pre>' + escapeHtml(textContent.slice(-200)) + '</pre>' +
            '<p><em>Notice how the JSON is truncated mid-content!</em></p>';

          console.error('JSON Parse Error:', e);
          console.log('Full textContent:', textContent);
        }
      }

      function escapeHtml(text) {
        return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }

      // Execute immediately - this is what immediate_hydration does
      tryParseProps();
    })();
  </script>

  <!--
    The JSON props script tag.
    In real React on Rails, this contains serialized component props.
    The bug occurs when the JS above runs before this tag is fully received.
  -->
  <script type="application/json" class="js-react-on-rails-component"
          id="js-react-on-rails-component-MyComponent-0"
          data-component-name="MyComponent"
          data-dom-id="MyComponent-react-component-0">
    {
      "componentId": 1,
      "message": "Hello World",
      "items": [
        {"id": 1, "name": "Item 1", "description": "This is a sample item with some text content to make it bigger"},
        {"id": 2, "name": "Item 2", "description": "This is a sample item with some text content to make it bigger"},
        {"id": 3, "name": "Item 3", "description": "This is a sample item with some text content to make it bigger"}
      ]
    }
  </script>

  <hr>

  <h2>How This Bug Occurs</h2>

  <pre>
Timeline with slow network:
────────────────────────────────────────────────────────────────────►

Browser receives HTML in chunks:

[Chunk 1]          [Chunk 2]              [Chunk 3]           [Chunk 4]
&lt;html&gt;...          &lt;script&gt;               {"componentId":1,   ...more JSON...
&lt;body&gt;...          tryParseProps()        "items":[           ...]}
                   &lt;/script&gt;              {"id":1...          &lt;/script&gt;
                        │
                        │
                        ▼
              JavaScript EXECUTES HERE
              ─────────────────────────
              scriptEl.textContent = '{"componentId":1,"items":[{"id":1...'
                                                                    ▲
                                                                    │
                                              TRUNCATED! (chunks 3-4 not received yet)

              JSON.parse(truncatedContent)
                        │
                        ▼
              SyntaxError: Unterminated string in JSON at position XXXXX
  </pre>

  <h2>Why <code>textContent</code> Returns Incomplete Data</h2>
  <p>
    The browser's HTML parser works incrementally. When JavaScript accesses
    <code>el.textContent</code>, it returns whatever content has been parsed
    <strong>so far</strong>. If the closing <code>&lt;/script&gt;</code> tag
    hasn't been received yet, you get truncated content.
  </p>

  <h2>The Fix</h2>
  <p>Wait for <code>DOMContentLoaded</code> before reading props, or verify the JSON is complete before parsing.</p>

</body>
</html>
